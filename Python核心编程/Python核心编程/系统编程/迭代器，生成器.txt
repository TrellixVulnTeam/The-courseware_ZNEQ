迭代：根据记录前面的元素去访问后面的元素
迭代器：可以记录遍历位置的对象
可迭代对象：能够被迭代访问的对象， for。。 in。。
如何判断可迭代对象  1.for。 in 。  2.isinstance（s，object）
from collections import Iterable  可迭代类型
可迭代对象的本质：提供了一个迭代器（用来遍历可迭代对象中的数据）
iter()获取可迭代对象提供的迭代器
通过next()方法可以访问迭代器中的元素，如果迭代去遍历完成，抛出StopIteration
python规定迭代器是一种可迭代对象，
自定义的可迭代对象的要求 1.实现__iter__() return一个可迭代的对象
                        2. 实现__next__() 调用 next()方法会调用__next__方法


生成器是一种特殊的迭代器，generator
列表推导式[]  ---> list
列表生成式()  ----> generator
生成器函数 yield 表达式
yield 有二个作用，1.将yield后面表达式的值，返回给调用函数的地方
                  2.当下一次继续调用生成器的时候，yield可以恢复之前正在执行的函数
                  3.第一次唤醒生成器函数的时候，必须next，
                  后面可以用send(args*)
阻塞等待通信模式  阻塞等待条件满足recv recvfrom accept
非阻塞通信模式 socket.setblocking(False)  实现的轮询的模式去判断是否有
客户端的连接，非常低效，用户体验不好
非阻塞是协程可以切换的前提

epoll是linux的操作系统中负责监听socket对象，当socket有数据时(比如有用户连接)，由操作系统通知用户进程

epoll  在unix中一切都是文件，文件描述符对读写文件资源的一个引用
我们操作文件描述符就可以操作文件资源，sock.fileno() 获取文件描述符
文件描述符是无符合整数（0，1，2.）
每个进程都有他自己的文件描述符
epoll对文件描述符的操作有二种模式LT<水平触发>（故障不除，红灯不灭）和ET<边沿触发>（只说一次，不在累赘）


创建套接字对象（tcp）
设置套接字重用
设置为非阻塞模式
绑定监听
创建epoll对象
开始用epoll对象监控服务器套接字（参数1 文件描述符，监听的类型和通知方式）
向 epoll获取监听的结果清单
遍历获取的结果清单，判断发生事件的套接字是谁
判断发生事件的套件子是谁，是服务器套件字说明客户端连接了

接收请求<异常处理>






